<html>
<head>
<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<style type='text/css'>
/*/*/ /*<![CDATA[*/
@import "file://G:/materials/Programming/SVNWorkspace/wiki/wpsrc/main.css";
#quickbar { position: absolute; left: 4px; }
#article { margin-left: 4px; margin-top: 4px; margin-right: 4px; }
a.new, #quickbar a.new { color: #CC2200; }

/*]]>*/ /* */
</style>
</head>
<body bgcolor='#FFFFFF' onload=''>
<div id="content">
<div id='article'>

<p><a href="Editing_Operation_Commit.html"><<</a> | <a href="Managing_repository_With_JavaSVN.html">List</a> |  <a href="Replicating_An_Existing_Repository.html">>></a>
<br />
<br />
</p>
<table id="toc" border="0"><tr><th>Table of contents</th></tr><tr><td><ol><li><a href="#Editing_Operation:_receiving_changes_from_a_repository"> Editing Operation: receiving changes from a repository </a>
</li><li><a href="#Reporting_a_local_versioned_tree_state_to_a_server-side"> Reporting a local versioned tree state to a server-side </a>
</li><li><a href="#Receiving_changes_from_a_server-side"> Receiving changes from a server-side </a>
</li><li><a href="#Example:_exporting_a_repository_directory"> Example: exporting a repository directory </a>
</li></ol></td></tr></table><hr/><a name="Editing_Operation:_receiving_changes_from_a_repository" id="Editing_Operation:_receiving_changes_from_a_repository"></a>
<h2> Editing Operation: receiving changes from a repository </h2><p>Another field of using <span class="nobr"><a href="http://tmate.org/svn/kb/javadoc/org/tmatesoft/svn/core/io/ISVNEditor.html" class="external" title="http://tmate.org/svn/kb/javadoc/org/tmatesoft/svn/core/io/ISVNEditor.html">ISVNEditor</a></span> is update 
operations (checkout, update, switch, export). But in update operations roles are just opposite to ones in commit 
operations: that is, while in a commit you <i>obtain</i> and use the library&#39;s editor to edit a repository, in an update 
you <i>provide</i> your own <b>ISVNEditor</b> implementation to the library which will be called by a repository server to 
transmit changes to a client side. If a remote access to a repository is used, it means that according to a particular 
access protocol a server sends commands which are translated by <b>JavaSVN</b> into calls to a client&#39;s editor. 
</p><p>
</p><p>
So, a low-level update operation takes two main stages:

</p><ul><li>a client application describes the state of the local versioned items tree to a repository;
</li><li>the infromation provided by the client is used by the server-side to decide what client items must be updated, such decisions are realized in calls to the client&#39;s editor.
</li></ul><p>In other words a client describes local revisions of the items to update, and a server traverses this tree to apply changes between what is in a repository and on the client&#39;s computer.
This mechanism gives a certain freedom in choosing the format of storing local versioned tree, what means that you are 
not restricted by the bounds of a general Working Copy.
</p>
<a name="Reporting_a_local_versioned_tree_state_to_a_server-side" id="Reporting_a_local_versioned_tree_state_to_a_server-side"></a>
<h2> Reporting a local versioned tree state to a server-side </h2><p>Descriptions of a local versioned tree state are made via the <span class="nobr"><a href="http://tmate.org/svn/kb/javadoc/org/tmatesoft/svn/core/io/ISVNReporter.html" class="external" title="http://tmate.org/svn/kb/javadoc/org/tmatesoft/svn/core/io/ISVNReporter.html">ISVNReporter</a></span> 
interface. We will study how to report local revisions by the example of using the low-level layer in the high-level one, 
i.e. we will describe how <b>JavaSVN</b> reports revisions of Working Copy items using <b>ISVNReporter</b>. 
</p><p>
</p><p>
Let&#39;s imagine we have got the following Working Copy tree:
</p><p><img src="Update_Tree1.png">
</p><p>A user performs a recursive update to the latest (HEAD) revision on the root of the Working Copy. How does <b>JavaSVN</b> make a report of local 
revisions in this case? First of all, reports are provided to an <b>SVNRepository</b> driver through an 
<span class="nobr"><a href="http://tmate.org/svn/kb/javadoc/org/tmatesoft/svn/core/io/ISVNReporterBaton.html" class="external" title="http://tmate.org/svn/kb/javadoc/org/tmatesoft/svn/core/io/ISVNReporterBaton.html">ISVNReporterBaton</a></span> implementation. 
When you pass it to an update method of <b>SVNRepository</b> the latter one calls the baton&#39;s <span class="nobr"><a href="http://tmate.org/svn/kb/javadoc/org/tmatesoft/svn/core/io/ISVNReporterBaton.html#report(org.tmatesoft.svn.core.io.ISVNReporter)" class="external" title="http://tmate.org/svn/kb/javadoc/org/tmatesoft/svn/core/io/ISVNReporterBaton.html#report(org.tmatesoft.svn.core.io.ISVNReporter)">report()</a></span> 
method passing it an <b>ISVNReporter</b> object.
</p><p>
</p><p>
Updating to the HEAD revision:

</p><div class="java"><pre>
    ...
    FSRepositoryFactory.setup();
    String url = <font color="#2A00FF">&#34;file://localhost/rep/nodeA/&#34;</font>;

    SVNRepository repository = SVNRepositoryFactory.create(SVNURL.parseURIDecoded(url));
    ReporterBaton reporterBaton = ...;
    ISVNEditor editor = ...;
    
    repository.update(&#45;1<font color="#3F7F5F">/&#42;forces to use the latest revision&#42;/</font>, <b><font color="#7F0055">null</font></b><font color="#3F7F5F">/&#42;target&#42;/</font>, <b><font color="#7F0055">true</font></b><font color="#3F7F5F">/&#42;recursive&#42;/</font>, reporterBaton, editor);
    ...
</pre></div><p>The <code>repository</code> driver passes an <b>ISVNReporter</b> object to our reporter baton&#39;s <code>report()</code> 
method. We are interested in what calls to an <b>ISVNReporter</b> object our reporter baton should make to report local 
revisions in our example on condition that a user calls a recursive update on the root of our Working Copy:

</p><div class="java"><pre>
...
<b><font color="#7F0055">public</font></b> <b><font color="#7F0055">class</font></b> ReporterBaton <b><font color="#7F0055">implements</font></b> ISVNReporterBaton &#123;

    ...
    
    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> report(ISVNReporter reporter) <b><font color="#7F0055">throws</font></b> SVNException &#123;
        
        <font color="#3F7F5F">//for the WC root
</font>        reporter.setPath(<font color="#2A00FF">&#34;&#34;</font><font color="#3F7F5F">/&#42;path&#42;/</font>, <b><font color="#7F0055">null</font></b><font color="#3F7F5F">/&#42;lockToken&#42;/</font>, 4<font color="#3F7F5F">/&#42;revision&#42;/</font>, <b><font color="#7F0055">false</font></b><font color="#3F7F5F">/&#42;startEmpty&#42;/</font>);

        ...
</pre></div><p>Here we should stop for some important notes. The first call to <b>ISVNReporter</b> is always <code>setPath(&quot;&quot;, ...)</code>, 
i.e. we always start reporting with the item upon which an update is called. If <code>target</code> parameter of an 
update method is <code>null</code> (like in our case) the <code>setPath(&quot;&quot;, ...)</code> call describes the node 
corresponding to the location to which the driver is bound to (<i>/nodeA</i>). Otherwise if <code>target</code> is not <code>null</code> 
it&#39;s a target item to update, and in this case <code>setPath(&quot;&quot;, ...)</code> describes this target item. Note that 
<code>target</code> is never a path but always a name. For example, if we wanted to update only <i>itemA1</i> we would 
call:

</p><div class="java"><pre>
    repository.update(&#45;1<font color="#3F7F5F">/&#42;revision&#42;/</font>, <font color="#2A00FF">&#34;itemA1&#34;</font><font color="#3F7F5F">/&#42;target&#42;/</font>, <b><font color="#7F0055">false</font></b><font color="#3F7F5F">/&#42;recursive&#42;/</font>, reporterBaton, editor);
</pre></div><p>Further we traverse our tree:

</p><div class="java"><pre>
        ...

        reporter.setPath(<font color="#2A00FF">&#34;nodeB&#34;</font>, <b><font color="#7F0055">null</font></b>, 5, <b><font color="#7F0055">false</font></b>);

        ...
</pre></div><p>There&#39;s no need to report <i>/nodeA/nodeB/itemB</i> since its current revision coincides with the revision of its parent 
directory and it&#39;s not locally locked. By the same reason we don&#39;t report <i>/nodeA/itemA1</i>, but we must report 
<i>/nodeA/itemA2</i> - although its revision is the same as the parent&#39;s one, but the item&#39;s locally locked, so maybe in a 
repository the lock is broken:

</p><div class="java"><pre>
        ...

        <font color="#3F7F5F">//provide the item&#39;s lock token
</font>        String lockToken = ...;
        reporter.setPath(<font color="#2A00FF">&#34;itemA2&#34;</font>, lockToken, 4, <b><font color="#7F0055">false</font></b>);

        ...
</pre></div><p>Continuing our report:

</p><div class="java"><pre>
        ...
        SVNURL url = SVNURL.parseURIDecoded(<font color="#2A00FF">&#34;file://localhost/rep/node2A/nodeC/nodeD/&#34;</font>);
        <font color="#3F7F5F">//switched paths are described in this way:
</font>        reporter.linkPath(url, <font color="#2A00FF">&#34;nodeC/nodeD&#34;</font>, <b><font color="#7F0055">null</font></b><font color="#3F7F5F">/&#42;lockToken&#42;/</font>, 4<font color="#3F7F5F">/&#42;revision&#42;/</font>, <b><font color="#7F0055">false</font></b><font color="#3F7F5F">/&#42;startEmpty&#42;/</font>);
        ...
</pre></div><p>Although the local revision number of <i>/nodeC/nodeD/</i> coincides with the revision number of the parent we need to 
report it as it&#39;s switched to another location of the repository.

</p><div class="java"><pre>
        ...
        reporter.deletePath(<font color="#2A00FF">&#34;nodeF&#34;</font>);
        reporter.deletePath(<font color="#2A00FF">&#34;nodeG&#34;</font>);
        reporter.deletePath(<font color="#2A00FF">&#34;nodeL&#34;</font>);
        ...
</pre></div><p><i>nodeF</i> is absent from our Working Copy. This means that we haven&#39;t got it previously because we don&#39;t have sufficient 
permissions on this directory. Furher we&#39;ll discuss how we get aware of absent directories and files when talking about 
editor invocations. 
</p><p>
</p><p>
<i>nodeG</i> was locally deleted and commited in the 6-th revision, but the WC root has not been updated since then. Now 
imagine that someone returned that directory in revision 7 in the state it was in revision 4 . If we considered that we 
don&#39;t have <i>nodeG</i>, so we don&#39;t need to report it,  we wouldn&#39;t get it back in an update to revision 7. This is 
because we report the WC root as in revision 4, but in revision 4 <i>nodeG</i> exists in the same state as in revision 7!
The case of absent nodes is similar: imagine that in revision 7 permission restrictions on <i>nodeF</i> were broken for 
you, but you won&#39;t get the directory if you don&#39;t say you don&#39;t have it. 
</p><p>
</p><p>
<i>nodeL</i> is missing from our Working Copy, i.e. it&#39;s still under version control but has been erased in the file system 
by a mistake. The idea is the same - we want to get the entire directory back into the Working Copy. However for a 
missing file (<i>itemA3</i>) there&#39;s no need to get the entire file since a missing file can be restored from the base 
(clear or unchanged) revision residing in an administrative folder (<i>.svn</i>) of the parent directory. 
</p><p>
</p><p>
This is why it&#39;s important to report deleted and absent nodes when their local revisions are different from the parent&#39;s one 
as well as report missing directories. 

</p><div class="java"><pre>
        ...

        reporter.setPath(<font color="#2A00FF">&#34;nodeH&#34;</font>, <b><font color="#7F0055">null</font></b>, 4, <b><font color="#7F0055">true</font></b><font color="#3F7F5F">/&#42;startEmpty&#42;/</font>);
        reporter.setPath(<font color="#2A00FF">&#34;nodeH/nodeH2&#34;</font>, <b><font color="#7F0055">null</font></b>, 4, <b><font color="#7F0055">false</font></b><font color="#3F7F5F">/&#42;startEmpty&#42;/</font>);
        reporter.setPath(<font color="#2A00FF">&#34;nodeH/itemH&#34;</font>, <b><font color="#7F0055">null</font></b>, 5, <b><font color="#7F0055">false</font></b><font color="#3F7F5F">/&#42;startEmpty&#42;/</font>);

        ...
        
</pre></div><p><i>nodeH</i> is incomplete what means that it was not updated entirely previous time (for example, an update operation was 
interrupted due to network connection problems or a server breakdown). So, we report incomplete directories as empty. 
And also we must report all children entries in an incomplete directory, doesn&#39;t matter whether their revisions are 
different from the parent&#39;s revision or not.
</p><p>
</p><p>
Another case of reporting a node as being empty is a checkout operation when initially you have no entries. In this case you 
make a single call to a reporter:

</p><div class="java"><pre>
        <b><font color="#7F0055">long</font></b> rev = ...;
        reporter.setPath(<font color="#2A00FF">&#34;&#34;</font>, <b><font color="#7F0055">null</font></b>, rev, <b><font color="#7F0055">true</font></b>);
</pre></div><p>Well, that&#39;s all for our example Working Copy tree. Items scheduled for either addition or deletion are not reported. 
We are finished:

</p><div class="java"><pre>
        ...
        
        <font color="#3F7F5F">//called at the end of a report
</font>        reporter.finishReport();
        
        ...
    &#125;
&#125;
</pre></div><p>If any method of <b>ISVNReporter</b> throws an exception you should abort the reorter in the following way:

</p><div class="java"><pre>
        ...
        
        <b><font color="#7F0055">try</font></b> &#123;
            ...        
            reporter.setPath(...);
            ...
        &#125; <b><font color="#7F0055">catch</font></b>(SVNException svne) &#123;
            reporter.abortReport();
            ...
        &#125;
        
        ...
</pre></div>

<a name="Receiving_changes_from_a_server-side" id="Receiving_changes_from_a_server-side"></a>
<h2> Receiving changes from a server-side </h2><p>Now we know that when you call an update method of an <b>SVNRepository</b> driver, the driver first invokes you reporter 
baton to get a client&#39;s report of a local tree state:

</p><div class="java"><pre>
    ...

    ISVNReporter reporter = ...;
    reporterBaton.report(reporter);

    ...
</pre></div><p>If our local tree (Working Copy, for instance) is successfully reported the diver calculates changes between our tree 
contents and what is in the repository. The driver passes these changes to the caller&#39;s editor as it traverses the tree. 
In other words, the driver <i>edits</i> our tree in a hierarchical way.
</p><p>
</p><p>
Let&#39;s proceed with our example. We have discussed how we should report our example Working Copy tree. Now we&#39;ll speak 
of how a server-side invokes our editor. First of all, it sets the actual revision which a local tree will be updated 
to, then opens the root node (the root of the Working Copyin in our case) and traverses the tree approximately like 
this:

</p><div class="java"><pre>
    ...

    <font color="#3F7F5F">//let HEAD revision be 7
</font>    editor.targetRevision(7);

    <font color="#3F7F5F">//gives the source revision we provided in our report
</font>    editor.openRoot(4);

    <font color="#3F7F5F">//in revision 7 properties were added for nodeB
</font>    editor.openDir(<font color="#2A00FF">&#34;nodeB&#34;</font>, 5);
    editor.changeDirProperty(<font color="#2A00FF">&#34;prop1&#34;</font>, <font color="#2A00FF">&#34;val1&#34;</font>);
    editor.changeDirProperty(<font color="#2A00FF">&#34;prop2&#34;</font>, <font color="#2A00FF">&#34;val2&#34;</font>);
    editor.closeDir();

    ...
    
    <font color="#3F7F5F">//receiving changes for a switched node &#45; nodeD
</font>    editor.openDir(<font color="#2A00FF">&#34;nodeC&#34;</font>, 4);
    editor.openDir(<font color="#2A00FF">&#34;nodeC/nodeD&#34;</font>, 4);
    <font color="#3F7F5F">//itemD2 was added under /node2A/nodeC/nodeD/ in the repository
</font>    editor.addFile(<font color="#2A00FF">&#34;nodeC/nodeD/itemD2&#34;</font>, <b><font color="#7F0055">null</font></b>, &#45;1);
    editor.applyTextDelta(<font color="#2A00FF">&#34;nodeC/nodeD/itemD2&#34;</font>, <b><font color="#7F0055">null</font></b>);
    editor.textDeltaChunk(<font color="#2A00FF">&#34;nodeC/nodeD/itemD2&#34;</font>, window1);
    ...
    editor.textDeltaEnd(<font color="#2A00FF">&#34;nodeC/nodeD/itemD2&#34;</font>);
    <font color="#3F7F5F">//text checksum
</font>    editor.closeFile(<font color="#2A00FF">&#34;nodeC/nodeD/itemD2&#34;</font>, checksum);
    <font color="#3F7F5F">//closing nodeC/nodeD
</font>    editor.closeDir();
    <font color="#3F7F5F">//closing nodeC
</font>    editor.closeDir();

    ...
    
    <font color="#3F7F5F">//we are still not permitted to read /nodeA/nodeF,
</font>    <font color="#3F7F5F">//this is how a server lets us know about this
</font>    editor.absentDir(<font color="#2A00FF">&#34;nodeF&#34;</font>);
    
    ...
    
</pre></div><p>All items which are located under an incomplete directory and have got the same revision as the incomplete parent&#39;s one 
are ADDED once again. But those items that have got revisions different from the incomplete parent&#39;s one will rather 
receive differences.

</p><div class="java"><pre>    
    editor.openDir(<font color="#2A00FF">&#34;nodeH&#34;</font>, 4);
    editor.addDir(<font color="#2A00FF">&#34;nodeH/nodeH2&#34;</font>, <b><font color="#7F0055">null</font></b>, &#45;1);
    <font color="#3F7F5F">//closing nodeH/nodeH2
</font>    editor.closeDir();

    editor.addDir(<font color="#2A00FF">&#34;nodeH/nodeH3&#34;</font>, <b><font color="#7F0055">null</font></b>, &#45;1);
    <font color="#3F7F5F">//closing nodeH/nodeH3
</font>    editor.closeDir();

    editor.addFile(<font color="#2A00FF">&#34;nodeH/itemH2&#34;</font>, <b><font color="#7F0055">null</font></b>, &#45;1);
    editor.applyTextDelta(<font color="#2A00FF">&#34;nodeH/itemH2&#34;</font>, <b><font color="#7F0055">null</font></b>);
    <font color="#3F7F5F">//sending delta windows
</font>    ...
    editor.textDeltaEnd(<font color="#2A00FF">&#34;nodeH/itemH2&#34;</font>);
    editor.closeFile(<font color="#2A00FF">&#34;nodeH/itemH2&#34;</font>, checksum);

    <font color="#3F7F5F">//receiving changes for nodeH/itemH
</font>    editor.openFile(<font color="#2A00FF">&#34;nodeH/itemH&#34;</font>, 5);
    editor.applyTextDelta(<font color="#2A00FF">&#34;nodeH/itemH&#34;</font>, baseChecksum);
    <font color="#3F7F5F">//sending delta windows
</font>    ...
    editor.textDeltaEnd(<font color="#2A00FF">&#34;nodeH/itemH&#34;</font>);
    editor.closeFile(<font color="#2A00FF">&#34;nodeH/itemH&#34;</font>, checksum);
    <font color="#3F7F5F">//closing nodeH
</font>    editor.closeDir();
    ...
    
    <font color="#3F7F5F">//the lock on itemA2 was broken in the repository
</font>    editor.changeFileProperty(<font color="#2A00FF">&#34;itemA2&#34;</font>, SVNProperty.LOCK_TOKEN, <b><font color="#7F0055">null</font></b>);
    
    ...
    
    <font color="#3F7F5F">//receiving a missing node &#45; /nodeA/nodeL
</font>    editor.addDir(<font color="#2A00FF">&#34;nodeL&#34;</font>, <b><font color="#7F0055">null</font></b>, &#45;1);
    ...
    editor.closeDir();
    
    ...
    
</pre></div><p>And so forth. 

</p><div class="java"><pre>
    ...
    
    <font color="#3F7F5F">//closes the WC root
</font>    editor.closeDir();
    <font color="#3F7F5F">//finishes editing
</font>    ediotr.closeEdit();
    
    ...
</pre></div><p>The update is finished. Now our Working Copy looks like this:
</p><p><img src="Update_Tree2.png">
</p><p>This is how a local tree is traversed and applied changes coming from a repository. To a certain extent, this is only an 
example, a scheme. Besides versioned properties files as well as directories receive some metadata - unmanaged (by a 
user) properties used for version control. We don&#39;t show them in our <i>demonstration</i> code. Nevertheless the main idea 
is correct. 
</p><p>
</p><p>
With a reporter (<b>ISVNReporter</b>) and an editor (<b>ISVNEditor</b>) you are not restricted by a Working Copy format.
The <b>JavaSVN</b> high-level engine implements an editor that stores a local data tree as directories and files within 
a Working Copy, but you can choose a different format of saving received versioned data for your editor. 
</p>
<a name="Example:_exporting_a_repository_directory" id="Example:_exporting_a_repository_directory"></a>
<h2> Example: exporting a repository directory </h2><p>In Subversion <i>export</i> is like checkout except that exported directories are clean, not versioned since they don&#39;t have 
administrative directories. This example demonstrates usage of <b>ISVNReporter</b> and <b>ISVNEditor</b> for exporting 
a directory from a repository. 
</p><p>
</p><p>
We implement the following reporter that reports our local tree as being empty:

</p><div class="java"><pre>
<b><font color="#7F0055">public</font></b> <b><font color="#7F0055">class</font></b> ExportReporterBaton <b><font color="#7F0055">implements</font></b> ISVNReporterBaton &#123;

    <b><font color="#7F0055">private</font></b> <b><font color="#7F0055">long</font></b> exportRevision;
        
    <b><font color="#7F0055">public</font></b> ExportReporterBaton(<b><font color="#7F0055">long</font></b> revision)&#123;
        exportRevision = revision;
    &#125;
        
    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> report(ISVNReporter reporter) <b><font color="#7F0055">throws</font></b> SVNException &#123;
        <b><font color="#7F0055">try</font></b> &#123;
            reporter.setPath(<font color="#2A00FF">&#34;&#34;</font>, <b><font color="#7F0055">null</font></b>, exportRevision, <b><font color="#7F0055">true</font></b>);
            reporter.finishReport();
        &#125; <b><font color="#7F0055">catch</font></b>(SVNException svne) &#123;
            reporter.abortReport();
            System.out.println(<font color="#2A00FF">&#34;Report failed&#34;</font>);
        &#125;
    &#125;
&#125;
</pre></div><p>And the editor which performs minimal work to save a coming versioned tree as files and directories:

</p><div class="java"><pre>
<b><font color="#7F0055">public</font></b> <b><font color="#7F0055">class</font></b> ExportEditor <b><font color="#7F0055">implements</font></b> ISVNEditor &#123;
        
    <b><font color="#7F0055">private</font></b> File myRootDirectory;
    <b><font color="#7F0055">private</font></b> SVNDeltaProcessor myDeltaProcessor;
        
    <b><font color="#7F0055">public</font></b> ExportEditor(File root) &#123;
        myRootDirectory = root;

        <font color="#3F7F5F">/&#42;
         &#42; Utility class that will help us to transform &#39;deltas&#39; sent by the 
         &#42; server to the new file contents.  
         &#42;/</font>
        myDeltaProcessor = <b><font color="#7F0055">new</font></b> SVNDeltaProcessor();
    &#125;

    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> targetRevision(<b><font color="#7F0055">long</font></b> revision) <b><font color="#7F0055">throws</font></b> SVNException &#123;
    &#125;

    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> openRoot(<b><font color="#7F0055">long</font></b> revision) <b><font color="#7F0055">throws</font></b> SVNException &#123;
    &#125;
        
    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> addDir(String path, String copyFromPath, <b><font color="#7F0055">long</font></b> copyFromRevision) <b><font color="#7F0055">throws</font></b> SVNException &#123;
        File newDir = <b><font color="#7F0055">new</font></b> File(myRootDirectory, path);
        <b><font color="#7F0055">if</font></b> (!newDir.exists()) &#123;
            <b><font color="#7F0055">if</font></b> (!newDir.mkdirs()) &#123;
                SVNErrorMessage err = SVNErrorMessage.create(SVNErrorCode.IO_ERROR, <font color="#2A00FF">&#34;error: failed to add the directory &#39;&#39;&#123;0&#125;&#39;&#39;.&#34;</font>, newDir);
                <b><font color="#7F0055">throw</font></b> <b><font color="#7F0055">new</font></b> SVNException(err);
            &#125;
        &#125;
        System.out.println(<font color="#2A00FF">&#34;dir added: &#34;</font> + path);
    &#125;
        
    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> openDir(String path, <b><font color="#7F0055">long</font></b> revision) <b><font color="#7F0055">throws</font></b> SVNException &#123;
    &#125;

    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> changeDirProperty(String name, String value) <b><font color="#7F0055">throws</font></b> SVNException &#123;
    &#125;

    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> addFile(String path, String copyFromPath, <b><font color="#7F0055">long</font></b> copyFromRevision) <b><font color="#7F0055">throws</font></b> SVNException &#123;
        File file = <b><font color="#7F0055">new</font></b> File(myRootDirectory, path);
        <b><font color="#7F0055">if</font></b> (file.exists()) &#123;
            SVNErrorMessage err = SVNErrorMessage.create(SVNErrorCode.IO_ERROR, <font color="#2A00FF">&#34;error: exported file &#39;&#39;&#123;0&#125;&#39;&#39; already exists!&#34;</font>, file);
            <b><font color="#7F0055">throw</font></b> <b><font color="#7F0055">new</font></b> SVNException(err);
        &#125;

        <b><font color="#7F0055">try</font></b> &#123;
            file.createNewFile();
        &#125; <b><font color="#7F0055">catch</font></b> (IOException e) &#123;
            SVNErrorMessage err = SVNErrorMessage.create(SVNErrorCode.IO_ERROR, <font color="#2A00FF">&#34;error: cannot create new  file &#39;&#39;&#123;0&#125;&#39;&#39;&#34;</font>, file);
            <b><font color="#7F0055">throw</font></b> <b><font color="#7F0055">new</font></b> SVNException(err);
        &#125;
    &#125;
        
    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> openFile(String path, <b><font color="#7F0055">long</font></b> revision) <b><font color="#7F0055">throws</font></b> SVNException &#123;
    &#125;

    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> changeFileProperty(String path, String name, String value) <b><font color="#7F0055">throws</font></b> SVNException &#123;
    &#125;        

    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> applyTextDelta(String path, String baseChecksum) <b><font color="#7F0055">throws</font></b> SVNException &#123;
        myDeltaProcessor.applyTextDelta(<b><font color="#7F0055">null</font></b>, <b><font color="#7F0055">new</font></b> File(myRootDirectory, path), <b><font color="#7F0055">false</font></b>);
    &#125;

    <b><font color="#7F0055">public</font></b> OutputStream textDeltaChunk(String path, SVNDiffWindow diffWindow)   <b><font color="#7F0055">throws</font></b> SVNException &#123;
        <b><font color="#7F0055">return</font></b> myDeltaProcessor.textDeltaChunk(diffWindow);
    &#125;
        
    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> textDeltaEnd(String path) <b><font color="#7F0055">throws</font></b> SVNException &#123;
        myDeltaProcessor.textDeltaEnd();
    &#125;
        
    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> closeFile(String path, String textChecksum) <b><font color="#7F0055">throws</font></b> SVNException &#123;
        System.out.println(<font color="#2A00FF">&#34;file added: &#34;</font> + path);
    &#125;

    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> closeDir() <b><font color="#7F0055">throws</font></b> SVNException &#123;
    &#125;

    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> deleteEntry(String path, <b><font color="#7F0055">long</font></b> revision) <b><font color="#7F0055">throws</font></b> SVNException &#123;
    &#125;
        
    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> absentDir(String path) <b><font color="#7F0055">throws</font></b> SVNException &#123;
    &#125;

    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> absentFile(String path) <b><font color="#7F0055">throws</font></b> SVNException &#123;
    &#125;        
        
    <b><font color="#7F0055">public</font></b> SVNCommitInfo closeEdit() <b><font color="#7F0055">throws</font></b> SVNException &#123;
        <b><font color="#7F0055">return</font></b> <b><font color="#7F0055">null</font></b>;
    &#125;
        
    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> abortEdit() <b><font color="#7F0055">throws</font></b> SVNException &#123;
    &#125;
&#125;
</pre></div><p>Having got these two implementations we export a directory from a world-readable repository:

</p><div class="java"><pre>
<b><font color="#7F0055">public</font></b> <b><font color="#7F0055">class</font></b> Export &#123;
    
    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">static</font></b> <b><font color="#7F0055">void</font></b> main(String&#91;&#93; args) &#123; 
        DAVRepositoryFactory.setup();
        SVNURL url = SVNURL.parseURIEncoded(<font color="#2A00FF">&#34;http://svn.tmate.org/svn/jsvn/trunk/doc&#34;</font>);
        String userName = <font color="#2A00FF">&#34;foo&#34;</font>;
        String userPassword = <font color="#2A00FF">&#34;bar&#34;</font>;
        
        <font color="#3F7F5F">//Prepare filesystem directory (export destination).
</font>        File exportDir = <b><font color="#7F0055">new</font></b> File(<font color="#2A00FF">&#34;export&#34;</font>);
        <b><font color="#7F0055">if</font></b> (exportDir.exists()) &#123;
            SVNErrorMessage err = SVNErrorMessage.create(SVNErrorCode.IO_ERROR, <font color="#2A00FF">&#34;Path &#39;&#39;&#123;0&#125;&#39;&#39; already exists&#34;</font>, exportDir);
            <b><font color="#7F0055">throw</font></b> <b><font color="#7F0055">new</font></b> SVNException(err);
        &#125;
        exportDir.mkdirs();

        SVNRepository repository = SVNRepositoryFactory.create(url);

        ISVNAuthenticationManager authManager = SVNWCUtil.createDefaultAuthenticationManager(userName, userPassword);
        repository.setAuthenticationManager(authManager);

        SVNNodeKind nodeKind = repository.checkPath(<font color="#2A00FF">&#34;&#34;</font>, &#45;1);
        <b><font color="#7F0055">if</font></b> (nodeKind == SVNNodeKind.NONE) &#123;
            SVNErrorMessage err = SVNErrorMessage.create(SVNErrorCode.UNKNOWN, <font color="#2A00FF">&#34;No entry at URL &#39;&#39;&#123;0&#125;&#39;&#39;&#34;</font>, url);
            <b><font color="#7F0055">throw</font></b> <b><font color="#7F0055">new</font></b> SVNException(err);
        &#125; <b><font color="#7F0055">else</font></b> <b><font color="#7F0055">if</font></b> (nodeKind == SVNNodeKind.FILE) &#123;
            SVNErrorMessage err = SVNErrorMessage.create(SVNErrorCode.UNKNOWN, <font color="#2A00FF">&#34;Entry at URL &#39;&#39;&#123;0&#125;&#39;&#39; is a file while directory was expected&#34;</font>, url);
            <b><font color="#7F0055">throw</font></b> <b><font color="#7F0055">new</font></b> SVNException(err);
        &#125;

        <font color="#3F7F5F">//Get latest repository revision. We will export repository contents at this very revision.
</font>        <b><font color="#7F0055">long</font></b> latestRevision = repository.getLatestRevision();
        
        ISVNReporterBaton reporterBaton = <b><font color="#7F0055">new</font></b> ExportReporterBaton(latestRevision);
        
        ISVNEditor exportEditor = <b><font color="#7F0055">new</font></b> ExportEditor(exportDir);
        
        <font color="#3F7F5F">/&#42;
         &#42; Now ask JavaSVN to perform generic &#39;update&#39; operation using our reporter and editor.
         &#42; 
         &#42; We are passing:
         &#42; 
         &#42; &#45; revision from which we would like to export
         &#42; &#45; null as &#34;target&#34; name, to perform export from the URL SVNRepository was created for, 
         &#42;   not from some child directory.
         &#42; &#45; reporterBaton
         &#42; &#45; exportEditor.  
         &#42;/</font>
        repository.update(latestRevision, <b><font color="#7F0055">null</font></b>, <b><font color="#7F0055">true</font></b>, reporterBaton, exportEditor);
        
        System.out.println(<font color="#2A00FF">&#34;Exported revision: &#34;</font> + latestRevision);
    
    &#125;
&#125;
</pre></div><hr/><p>Download the <span class="nobr"><a href="http://svn.tmate.org/repos/jsvn/trunk/doc/examples/src/org/tmatesoft/svn/examples/repository/Export.java" class="external" title="http://svn.tmate.org/repos/jsvn/trunk/doc/examples/src/org/tmatesoft/svn/examples/repository/Export.java">example program source code</a></span>.
</p><p><br />
<br />
<a href="Editing_Operation_Commit.html"><<</a> | <a href="Managing_repository_With_JavaSVN.html">List</a> |  <a href="Replicating_An_Existing_Repository.html">>></a>
</p>    

</div>
</div>
</body>
</html>